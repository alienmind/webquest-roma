<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Escritores de la Antigua Roma: ¬°Una Aventura Literaria!</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/theme/league.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/plugin/highlight/monokai.min.css">
    <style>
        .reveal {
            font-size: 32px; /* Base size - adjust as needed */
        }

        .reveal .slides {
            text-align: left; /* Better text distribution */
        }

        .reveal p {
            font-size: 0.7em; /* Smaller paragraph text */
            line-height: 1.4;
            margin-bottom: 0.8em;
        }

        .reveal h1 {
            font-size: 1.6em;
            margin-bottom: 0.5em;
        }

        .reveal h2 {
            font-size: 1.3em;
            margin-bottom: 0.4em;
            position: relative;
            text-align: center;
            padding: 0 50px;
        }

        .reveal h3 {
            font-size: 1.1em;
            margin-bottom: 0.3em;
        }

        .reveal h2::before,
        .reveal h2::after {
            content: 'üèõÔ∏è';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8em;
            opacity: 0.7;
            color: #aaa;
        }

        .reveal h2::before {
            left: 10px;
        }

        .reveal h2::after {
            right: 10px;
        }

        .reveal ul, .reveal ol {
            font-size: 0.7em;
            display: block;
            margin-left: 1em;
        }

        .reveal section img { margin: 15px 0px; border: 0px; background: none; box-shadow: none; }
        .reveal .controls button { color: #555; }
        .reveal .progress { background: rgba(0,0,0,0.2); height: 4px; }
        .reveal .progress span { background: #555; }

        .crucigrama { display: grid; grid-template-columns: repeat(10, 30px); grid-gap: 2px; }
        .crucigrama input { width: 30px; height: 30px; text-align: center; font-size: 1.2em; border: 1px solid #ccc; text-transform: uppercase; }
        .crucigrama input.correcto { background-color: #ccffcc; }

        .kahoot-link { display: inline-block; padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none; border-radius: 5px; }
        .kahoot-link:hover { background-color: #3e8e41; }

        .game-container {
            max-width: 90%;
            font-size: 0.8em;
            margin: 1em auto;
        }

        .drag-container {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            justify-content: center;
        }

        .draggable {
            padding: 10px 20px;
            background: #4a4a4a;
            color: white;
            border-radius: 5px;
            cursor: move;
            user-select: none;
        }

        .dropzone {
            display: inline-block;
            min-width: 80px;
            padding: 5px 10px;
            border: 2px dashed #666;
            border-radius: 5px;
            text-align: center;
        }

        .dropzone.active {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .sortable-list {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
        }

        .sortable-item {
            padding: 12px 15px;
            background: #4a4a4a;
            color: white;
            margin: 8px 0;
            border-radius: 5px;
            cursor: grab;
            user-select: none;
            position: relative;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .sortable-item:active {
            cursor: grabbing;
            transform: scale(1.02);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .sortable-item.dragging {
            opacity: 0.5;
            background: #666;
        }

        .sortable-item.over {
            border-top: 2px solid #FFF;
        }

        .memory-game {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }

        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin: 20px 0;
        }

        .memory-card {
            position: relative;
            width: 100%;
            aspect-ratio: 4/3;
            perspective: 1000px;
            cursor: pointer;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .memory-card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            border-radius: 10px;
            padding: 5px;
            box-sizing: border-box;
        }

        .card-front {
            background: linear-gradient(45deg, #4a4a4a, #2a2a2a);
            color: transparent;
        }

        .card-back {
            background: #3a3a3a;
            transform: rotateY(180deg);
            font-size: 0.75em;
            line-height: 1.2;
        }

        @keyframes matchShake {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(-5deg) scale(1.1); }
            75% { transform: rotate(5deg) scale(1.1); }
            100% { transform: rotate(0deg) scale(1); }
        }

        .memory-card.matched .card-inner {
            animation: matchShake 0.5s ease-in-out;
            background: #4CAF50;
        }

        .feedback {
            font-size: 0.8em;
            margin: 0.8em 0;
            padding: 10px;
            border-radius: 5px;
        }

        .feedback.success {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .feedback.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .input-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 600px;
            margin: 0 auto;
        }

        .input-container textarea {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            resize: vertical;
        }

        .input-container button {
            align-self: center;
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 10px;
        }

        .crossword-container {
            display: flex;
            gap: 20px;
            max-width: 900px;
            margin: 0 auto;
            font-size: 0.8em;
        }

        .crossword-grid {
            display: grid;
            grid-template-columns: repeat(10, 35px);
            gap: 1px;
            background: #333;
            padding: 1px;
        }

        .crossword-cell {
            width: 35px;
            height: 35px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            position: relative;
            cursor: pointer;
        }

        .crossword-cell input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-size: 1.2em;
            text-transform: uppercase;
            background: white;
            color: #333;
        }

        .crossword-cell input:focus {
            outline: 2px solid #4CAF50;
        }

        .crossword-cell.black {
            background: #333;
        }

        .crossword-cell .number {
            position: absolute;
            top: 1px;
            left: 1px;
            font-size: 0.6em;
            color: #666;
        }

        .crossword-clues {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .crossword-clues h3 {
            margin-bottom: 10px;
        }

        .crossword-clues ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .crossword-clues li {
            margin-bottom: 5px;
            cursor: pointer;
        }

        .crossword-clues li:hover {
            color: #4CAF50;
        }

        .game-instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .game-instructions h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        #wordSearchContainer {
            display: flex;
            gap: 40px;
            max-width: 800px;
            margin: 20px auto;
            justify-content: center;
            align-items: flex-start;
        }

        #wordSearchGrid {
            display: grid;
            grid-template-columns: repeat(10, 40px);
            gap: 1px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
        }

        .word-cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #fff;
            border: 1px solid #ddd;
            font-weight: bold;
            user-select: none;
            cursor: pointer;
            transition: all 0.2s;
            color: #000; /* Make text black */
        }

        .word-cell.selected {
            background-color: #d3d3d3; /* Light gray instead of yellow */
            transform: scale(1.05);
        }

        .word-cell.highlighted {
            background-color: #4CAF50;
            color: white;
            transform: none; /* Reset any scaling */
            border-color: #2e7d32; /* Darker green border */
        }

        #wordList {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #wordList li {
            padding: 8px 15px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 1.1em;
            transition: all 0.3s ease;
            color: transparent;
            position: relative;
        }

        #wordList li::before {
            content: '????????';
            color: rgba(255, 255, 255, 0.5);
            position: absolute;
            left: 15px;
            top: 8px;
        }

        #wordList li.found {
            background: #4CAF50;
            color: white;
            text-decoration: none;
        }

        #wordList li.found::before {
            display: none;
        }

        .legacy-match-container {
            display: flex;
            justify-content: space-around;
            gap: 30px;
            max-width: 900px;
            margin: 30px auto;
            align-items: flex-start;
        }

        .legacy-column {
            width: 45%;
            background: rgba(0, 0, 0, 0.1);
            padding: 15px;
            border-radius: 8px;
        }

        .legacy-column h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #eee;
        }

        .legacy-item {
            background: #4a4a4a;
            color: white;
            padding: 8px 10px;
            margin: 8px 0;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            text-align: center;
            font-size: 0.9em;
        }

        .legacy-item:hover {
            background: #5a5a5a;
            transform: scale(1.02);
        }

        .legacy-item.selected {
            border-color: #4CAF50;
            background: #5a5a5a;
            transform: scale(1.03);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .legacy-item.matched {
            background: #4CAF50;
            color: white;
            cursor: default;
            opacity: 0.7;
            pointer-events: none;
        }

        #legacy-feedback {
          font-size: 1em;
        }

        .corner-image {
            position: absolute;
            top: 30px;
            right: 30px;
            max-width: 80px;
            max-height: 80px;
            opacity: 0.6;
            border-radius: 5px;
            z-index: 1;
        }

        .author-name {
            color: #acb8ee;
            font-weight: bold;
            font-style: italic;
        }

        #easter-egg-trigger:hover {
             text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        .flying-heart {
            position: absolute;
            font-size: 10px;
            color: red;
            opacity: 1;
            animation: growFadeOut 1s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }

        @keyframes growFadeOut {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(5); opacity: 0; }
        }

        /* Memory Game */
        .memory-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 1em 0;
        }
        
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 1em;
            max-width: 700px;
        }
        
        .memory-card {
            width: 130px;
            height: 75px;
            background-color: #f0f0f0;
            border-radius: 8px;
            cursor: pointer;
            perspective: 1000px;
        }
        
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        
        .memory-card.flipped .card-inner {
            transform: rotateY(180deg);
        }
        
        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-weight: bold;
            font-size: 0.75em;
            padding: 5px;
        }
        
        .card-front {
            background-color: #333;
            color: white;
            font-size: 24px;
        }
        
        .card-back {
            background-color: #2b68d8;
            color: #333;
            transform: rotateY(180deg);
        }
        
        .memory-card.matched .card-inner {
            animation: matchShake 0.5s ease-in-out;
            background: #4CAF50; /* Green background */
        }
        
        .memory-card.matched .card-back {
            background-color: #4CAF50; /* Green background */
            color: white;
        }
        
        @keyframes matchShake {
            0% { transform: rotateY(180deg) rotate(0deg) scale(1); }
            25% { transform: rotateY(180deg) rotate(-5deg) scale(1.1); }
            75% { transform: rotateY(180deg) rotate(5deg) scale(1.1); }
            100% { transform: rotateY(180deg) rotate(0deg) scale(1); }
        }
        
        /* Word Search Grid Adjustments */
        #wordSearchGridVida {
            display: grid;
            grid-template-columns: repeat(10, 40px);
            grid-template-rows: repeat(10, 40px);
            gap: 1px;
            border: 2px solid #ddd;
            padding: 5px;
            background-color: #f5f5f5;
            margin: 0 auto;
        }
        
        /* Vida romana word search container */
        #wordSearchContainerVida {
            display: flex;
            gap: 40px;
            max-width: 800px;
            margin: 20px auto;
            justify-content: center;
            align-items: flex-start;
        }
        
        /* Word list formatting */
        #wordListVida {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        #wordListVida li {
            padding: 8px 15px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 1.1em;
            transition: all 0.3s ease;
            color: transparent;
            position: relative;
        }
        
        #wordListVida li::before {
            content: '????????';
            color: rgba(255, 255, 255, 0.5);
            position: absolute;
            left: 15px;
            top: 8px;
        }
        
        #wordListVida li.found {
            background: #4CAF50;
            color: white;
            text-decoration: none;
        }
        
        #wordListVida li.found::before {
            display: none;
        }
        
        .wordsearch-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 1em 0;
        }
        
        .word-cell {
            width: 40px;
            height: 40px;
            display: flex;
            background-color: #fff;
            border: 1px solid #ddd;
            font-weight: bold;
            user-select: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .word-cell.selected {
            background-color: #ffd700;
            transform: scale(1.05);
        }
        
        .word-cell.highlighted {
            background-color: #4CAF50;
            color: white;
        }
        
        .word-list-container {
            flex: 1;
            min-width: 200px;
            max-width: 300px;
        }
        
        .word-list {
            list-style-type: none;
            padding: 0;
            opacity: 0.7;
        }
        
        .word-list li {
            margin-bottom: 0.5em;
            font-weight: bold;
            color: #333;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .word-list li.found {
            opacity: 1;
            color: #4caf50;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h1>¬°Bienvenidos, exploradores de la Antigua Roma!</h1>
                <p>¬øListos para un viaje a trav√©s del tiempo y descubrir a los genios literarios que iluminaron Roma?</p>
                <p style="font-size: 0.8em; margin-top: 20px;">Por <span class="author-name">Eva Margarita Garc√≠a</span></p>
                <img align="center" src="img/teatro.png" alt="Roma Antigua" style="max-width: 500px;">
            </section>

            <section>
                <h2>La misi√≥n: Desenterrar el Legado Literario</h2>
                <p>Vuestra tarea es convertiros en arque√≥logos de las palabras. Investigaremos la vida y obra de los grandes escritores romanos a trav√©s de juegos, acertijos y desaf√≠os.</p>
                <p>¬°Preparaos para leer, investigar y divertiros!</p>
            </section>

            <section>
                <section>
                    <h2>Reto 1: Virgilio - El Poeta √âpico</h2>
                    <div class="game-container">
                        <p>Arrastra las palabras correctas para completar el texto sobre la Eneida:</p>
                        <div class="drag-container">
                            <div class="draggable" draggable="true">Eneas</div>
                            <div class="draggable" draggable="true">Troya</div>
                            <div class="draggable" draggable="true">Roma</div>
                            <div class="draggable" draggable="true">Dido</div>
                        </div>
                        <div class="text-container">
                            <p>El h√©roe <span class="dropzone" data-answer="Eneas">_____</span> huye de 
                            <span class="dropzone" data-answer="Troya">_____</span> y viaja hasta fundar lo que ser√° 
                            <span class="dropzone" data-answer="Roma">_____</span>. En su viaje, conoce a la reina 
                            <span class="dropzone" data-answer="Dido">_____</span>.</p>
                        </div>
                        <div id="virgilio-feedback" class="feedback"></div>
                    </section>
                
                <section>
                    <h2>Soluci√≥n: Virgilio</h2>
                    <p>La Eneida narra el viaje de Eneas desde Troya hasta la fundaci√≥n de Roma, incluyendo su encuentro con la reina Dido.</p>
                    <p>Este poema √©pico fue fundamental como propaganda del imperio Romano, conectando sus or√≠genes con la legendaria Troya.</p>
                    <img align="center" src="img/virgilio.png" alt="Virgilio" style="max-width: 400px;">
                </section>
            </section>

            <section>
                <section>
                    <h2>Reto 2: Cicer√≥n - El Orador Maestro</h2>
                    <div class="game-container">
                        <h3>¬°Ordena los Eventos!</h3>
                        <p>Arrastra los eventos de la vida de Cicer√≥n en orden cronol√≥gico:</p>
                        <div class="sortable-list">
                            <div class="sortable-item" data-order="4">Es elegido c√≥nsul</div>
                            <div class="sortable-item" data-order="1">Nace en Arpino</div>
                            <div class="sortable-item" data-order="5">Descubre la conspiraci√≥n de Catilina</div>
                            <div class="sortable-item" data-order="2">Estudia ret√≥rica en Roma</div>
                            <div class="sortable-item" data-order="3">Defiende a Roscio en su primer caso</div>
                        </div>
                        <button onclick="checkCiceroOrder()" class="check-button">Verificar Orden</button>
                        <div id="cicero-feedback" class="feedback"></div>
                    </div>
                </section>

                <section>
                    <h2>Soluci√≥n: Cicer√≥n</h2>
                    <p>Cicer√≥n fue un brillante orador y pol√≠tico que defendi√≥ la Rep√∫blica Romana.</p>
                    <p>Naci√≥ en Arpino, Italia en el a√±o 106 a.C.</p>
                    <p>Estudi√≥ ret√≥rica en Atenas y Rodas del a√±o 79 a.C. al 77 a.C.</p>
                    <p>Su primer caso fue defender a Roscio en el a√±o 79 a.C.</p>
                    <p>Fue elegido c√≥nsul en el a√±o 63 a.C.</p>
                    <p>Descubri√≥ la conspiraci√≥n de Catilina que intent√≥ sobornar para postularse como c√≥nsul.</p>
                    <img align="center" src="img/ciceron.png" alt="Ciceron" style="max-width: 400px;">
                </section>
            </section>

            <section>
                <section>
                    <h2>Reto 3: Memoria Literaria</h2>
                    <div class="memory-game">
                        <div class="game-instructions">
                            <h3>¬øC√≥mo jugar?</h3>
                            <p>Encuentra las parejas de escritores romanos y sus obras m√°s famosas. Cada escritor tiene una obra correspondiente.</p>
                            <ul>
                                <li>Haz clic en una carta para revelarla</li>
                                <li>Encuentra su pareja (escritor-obra) entre las dem√°s cartas</li>
                                <li>¬°Las parejas correctas permanecer√°n visibles!</li>
                            </ul>
                        </div>
                        <div class="memory-grid">
                            <!-- Cards will be generated by JavaScript -->
                        </div>
                        <div id="memory-score">Parejas encontradas: 0/6</div>
                    </div>
                </section>

                <section>
                    <h2>Soluci√≥n: Conexiones Literarias</h2>
                    <p>Las parejas que has descubierto representan las obras m√°s importantes de cada autor:</p>
                    <ul>
                        <li><strong>Virgilio - Eneida:</strong> La epopeya que narra el viaje de Eneas</li>
                        <li><strong>Ovidio - Metamorfosis:</strong> Poema sobre transformaciones m√≠ticas</li>
                        <li><strong>Cicer√≥n - Catilinarias:</strong> Discursos contra la conspiraci√≥n de Catilina</li>
                        <li><strong>Horacio - Odas:</strong> Poemas l√≠ricos sobre la vida y la naturaleza</li>
                        <li><strong>S√©neca - Medea:</strong> Tragedia sobre la venganza de una hechicera</li>
                        <li><strong>Plauto - Aulularia:</strong> Comedia sobre un avaro y su olla de oro</li>
                    </ul>
                </section>
            </section>

            <section>
                <section>
                    <h2>Reto 4: Sopa de Letras Latina</h2>
                    <div class="game-instructions">
                        <h3>¬øC√≥mo jugar?</h3>
                        <p>Encuentra las palabras latinas ocultas en la cuadr√≠cula. Puedes buscar horizontal o verticalmente.</p>
                        <ul>
                            <li>Haz clic y arrastra para seleccionar las letras</li>
                            <li>Las palabras encontradas se marcar√°n en verde</li>
                            <li>¬°Encuentra todas las palabras para completar el reto!</li>
                        </ul>
                    </div>
                    <div id="wordSearchContainer">
                        <div>
                            <div id="wordSearchGrid"></div>
                        </div>
                        <div>
                            <h3>Palabras a encontrar:</h3>
                            <ul id="wordList"></ul>
                        </div>
                    </div>
                </section>
                
                <section>
                    <h2>Soluci√≥n: Palabras Latinas</h2>
                    <ul>
                        <li><strong>POETA</strong> - Escritor de versos</li>
                        <li><strong>LIBER</strong> - Libro</li>
                        <li><strong>VERBA</strong> - Palabras</li>
                        <li><strong>AUCTOR</strong> - Autor</li>
                        <li><strong>CARMEN</strong> - Poema</li>
                    </ul>
                </section>
            </section>

            <section>
                <section>
                    <h2>Reto 5: Conecta el Legado</h2>
                    <div class="game-instructions">
                        <h3>¬øC√≥mo jugar?</h3>
                        <p>Une a cada escritor romano con el √°rea o g√©nero que m√°s influenci√≥. Haz clic en un escritor y luego en su influencia correcta.</p>
                        <ul>
                            <li>Haz clic en un escritor (columna izquierda).</li>
                            <li>Luego haz clic en la influencia correcta (columna derecha).</li>
                            <li>¬°Las parejas correctas se conectar√°n visualmente!</li>
                        </ul>
                    </div>
                    <div class="legacy-match-container">
                        <div class="legacy-column" id="writersColumn">
                            <h3>Escritores</h3>
                            <div class="legacy-item" data-id="virgilio">Virgilio</div>
                            <div class="legacy-item" data-id="ciceron">Cicer√≥n</div>
                            <div class="legacy-item" data-id="ovidio">Ovidio</div>
                            <div class="legacy-item" data-id="seneca">S√©neca</div>
                            <div class="legacy-item" data-id="plauto">Plauto</div>
                        </div>
                        <div class="legacy-column" id="influencesColumn">
                            <h3>Influencia Principal</h3>
                            <div class="legacy-item" data-match="ciceron">Oratoria y Prosa Filos√≥fica</div>
                            <div class="legacy-item" data-match="plauto">Comedia Teatral (Situacional)</div>
                            <div class="legacy-item" data-match="virgilio">Poes√≠a √âpica Occidental</div>
                            <div class="legacy-item" data-match="seneca">Tragedia y Filosof√≠a Estoica</div>
                            <div class="legacy-item" data-match="ovidio">Mitolog√≠a y Poes√≠a Amorosa</div>
                        </div>
                    </div>
                    <div id="legacy-feedback" class="feedback" style="text-align: center; margin-top: 20px;"></div>
                </section>

                <section>
                    <h2>Soluci√≥n: El Legado de Roma</h2>
                    <p>Las conexiones correctas muestran c√≥mo estos gigantes literarios moldearon el futuro:</p>
                    <ul>
                        <li><strong>Virgilio:</strong> Su <em>Eneida</em> defini√≥ la poes√≠a √©pica para siglos.</li>
                        <li><strong>Cicer√≥n:</strong> Estableci√≥ el est√°ndar para la oratoria y la escritura filos√≥fica en lat√≠n.</li>
                        <li><strong>Ovidio:</strong> Sus <em>Metamorfosis</em> se convirtieron en la fuente principal de mitolog√≠a cl√°sica para artistas y escritores posteriores.</li>
                        <li><strong>S√©neca:</strong> Influy√≥ en la tragedia renacentista (como Shakespeare) y populariz√≥ el estoicismo.</li>
                        <li><strong>Plauto:</strong> Sus tramas y personajes c√≥micos fueron adaptados por Moli√®re, Shakespeare y comedias modernas.</li>
                    </ul>
                </section>
            </section>

            <section>
                <section>
                    <h2>Reto 6: Ovidio - El Maestro de la Metamorfosis</h2>
                    <div class="game-container">
                        <p>Completa el pasaje sobre la transformaci√≥n de Dafne seg√∫n Ovidio:</p>
                        <div class="drag-container" id="drag-container-ovidio">
                            <div class="draggable" draggable="true">Apolo</div>
                            <div class="draggable" draggable="true">Dafne</div>
                            <div class="draggable" draggable="true">Laurel</div>
                            <div class="draggable" draggable="true">Peneo</div>
                        </div>
                        <div class="text-container">
                            <p>El dios <span class="dropzone ovidio-dropzone" data-answer="Apolo">_____</span> persegu√≠a a la ninfa <span class="dropzone ovidio-dropzone" data-answer="Dafne">_____</span>, quien rog√≥ a su padre, el r√≠o <span class="dropzone ovidio-dropzone" data-answer="Peneo">_____</span>, que la transformara. As√≠ se convirti√≥ en un √°rbol de <span class="dropzone ovidio-dropzone" data-answer="Laurel">_____</span>.</p>
                        </div>
                        <div id="ovidio-feedback" class="feedback"></div>
                    </div>
                </section>
                <section>
                    <h2>Soluci√≥n: Ovidio y Dafne</h2>
                    <p>En las <em>Metamorfosis</em> de Ovidio, Apolo, dios de la arquer√≠a y la m√∫sica, se enamora perdidamente de la ninfa Dafne. Ella, para escapar de su persecuci√≥n, pide ayuda a su padre, el dios r√≠o Peneo. Este la transforma en un laurel, √°rbol que desde entonces se volvi√≥ sagrado para Apolo.</p>
                    <img align="center" src="img/dafneapolo.png" alt="Ovidio - Dafne y Apolo" style="max-width: 400px;">
                </section>
            </section>

            <section>
                <section>
                    <h2>Reto 7: S√©neca - El Fil√≥sofo Estoico</h2>
                    <div class="game-container">
                        <h3>¬°Eventos Clave de S√©neca!</h3>
                        <p>Ordena cronol√≥gicamente estos momentos de la vida de Lucio Anneo S√©neca:</p>
                        <div class="sortable-list" id="seneca-sortable-list">
                            <div class="sortable-item" data-order="3">Tutor del joven emperador Ner√≥n</div>
                            <div class="sortable-item" data-order="1">Nacimiento en Corduba, Hispania</div>
                            <div class="sortable-item" data-order="4">Escribe "Cartas a Lucilio"</div>
                            <div class="sortable-item" data-order="2">Exilio a C√≥rcega</div>
                            <div class="sortable-item" data-order="5">Forzado al suicidio por Ner√≥n</div>
                        </div>
                        <button onclick="checkSenecaOrder()" class="check-button">Verificar Orden</button>
                        <div id="seneca-feedback" class="feedback"></div>
                    </div>
                    <img align="center" src="img/seneca.png" alt="" class="corner-image">
                </section>
                <section>
                    <h2>Soluci√≥n: Hitos de S√©neca</h2>
                    <p>La vida de S√©neca estuvo marcada por grandes altibajos y una profunda reflexi√≥n filos√≥fica:</p>
                    <ol>
                        <li>Nacimiento en Corduba, Hispania.</li>
                        <li>Exilio a C√≥rcega bajo el emperador Claudio.</li>
                        <li>Regreso a Roma y tutor√≠a del joven Ner√≥n.</li>
                        <li>Escritura de sus influyentes obras filos√≥ficas, incluyendo las "Cartas a Lucilio".</li>
                        <li>Forzado al suicidio por orden de Ner√≥n, enfrentando la muerte con serenidad estoica.</li>
                    </ol>
                    <img align="center" src="img/senecamuerte.jpg" alt="Muerte de S√©neca" style="max-width: 400px;">
                </section>
            </section>

            <section>
                <section>
                    <h2>Reto 8: Pante√≥n Romano-Griego</h2>
                    <div class="memory-game">
                        <div class="game-instructions">
                            <h3>¬øC√≥mo jugar?</h3>
                            <p>Encuentra las parejas de dioses romanos y sus equivalentes griegos.</p>
                        </div>
                        <div class="memory-grid" id="panteon-memory-grid">
                            {/* Cards will be generated by JavaScript */}
                        </div>
                        <div id="panteon-memory-score">Parejas encontradas: 0/6</div>
                    </div>
                </section>
                <section>
                    <h2>Soluci√≥n: Dioses Hermanados</h2>
                    <p>Los romanos adoptaron y adaptaron muchos dioses griegos:</p>
                    <ul>
                        <li><strong>J√∫piter (Romano) - Zeus (Griego):</strong> Rey de los dioses.</li>
                        <li><strong>Juno (Romana) - Hera (Griega):</strong> Reina de los dioses, diosa del matrimonio.</li>
                        <li><strong>Marte (Romano) - Ares (Griego):</strong> Dios de la guerra.</li>
                        <li><strong>Venus (Romana) - Afrodita (Griega):</strong> Diosa del amor y la belleza.</li>
                        <li><strong>Neptuno (Romano) - Poseid√≥n (Griego):</strong> Dios del mar.</li>
                        <li><strong>Minerva (Romana) - Atenea (Griega):</strong> Diosa de la sabidur√≠a y la guerra estrat√©gica.</li>
                    </ul>
                    <img align="center" src="img/panteon.png" alt="Dioses Romanos y Griegos" style="max-width: 400px;">
                </section>
            </section>

            <section>
                <section>
                    <h2>Reto 9: Sopa de Letras - Vida Romana</h2>
                    <div class="game-instructions">
                        <h3>¬øC√≥mo jugar?</h3>
                        <p>Encuentra palabras relacionadas con la vida diaria en Roma. Haz clic y arrastra para seleccionar las letras.</p>
                    </div>
                    <div id="wordSearchContainerVida">
                        <div>
                            <div id="wordSearchGridVida"></div>
                        </div>
                        <div>
                            <h3>Palabras a encontrar:</h3>
                            <ul id="wordListVida"></ul>
                        </div>
                    </div>
                </section>
                <section>
                    <h2>Soluci√≥n: T√©rminos de la Vida Romana</h2>
                    <ul>
                        <li><strong>DOMUS</strong> - Casa unifamiliar romana.</li>
                        <li><strong>FORUM</strong> - Centro de la vida p√∫blica y comercial.</li>
                        <li><strong>SENATUS</strong> - El Senado romano, principal √≥rgano de gobierno.</li>
                        <li><strong>AQUA</strong> - Agua, esencial y distribuida por acueductos.</li>
                        <li><strong>VIA</strong> - Calzada o camino romano.</li>
                        <li><strong>CIVIS</strong> - Ciudadano romano.</li>
                    </ul>
                    <img align="center" src="img/vidaromana.png" alt="Escena de vida romana" style="max-width: 400px;">
                </section>
            </section>

            <section>
                <h2>¬°Misi√≥n cumplida!</h2>
                <p>¬°Felicidades, arque√≥logos literarios! Hab√©is desenterrado el tesoro de los escritores romanos.</p>
                <p>Esperamos que este viaje os haya inspirado a explorar m√°s la literatura cl√°sica.</p>
                <img align="center" src="img/biblioteca.png" alt="Biblioteca" style="max-width: 500px;">
            </section>

            <section>
                <h2>Bibliograf√≠a y Recursos</h2>
                <ul>
                    <li><a href="https://www.perseus.tufts.edu/hopper/" target="_blank">Perseus Digital Library</a> - Textos originales de autores cl√°sicos</li>
                    <li><a href="https://thelatinlibrary.com/" target="_blank">The Latin Library</a> - Colecci√≥n de textos latinos</li>
                    <li><a href="https://www.livius.org/articles/person/virgil/" target="_blank">Livius.org: Virgilio</a> - Biograf√≠a y contexto hist√≥rico</li>
                    <li><a href="https://www.britannica.com/biography/Cicero" target="_blank">Encyclopaedia Britannica: Cicer√≥n</a> - Vida y obra</li>
                    <li><a href="https://www.amazon.es/Acepta-inevitable-estoicas-autoconocimiento-singulares/dp/8441546762" target="_blank">Acepta lo inevitable. Citas estoicas para el autoconocimiento - Garc√≠a, Eva Margarita</a> - Relacionado con el estoicismo de S√©neca</li>
                </ul>
                <p style="font-size: 0.8em; margin-top: 20px;">Algunas im√°genes utilizadas son de dominio p√∫blico o tienen licencia Creative Commons.</p>
                <p style="font-size: 0.4em; margin-top: 40px; text-align: center; position: relative;">
                    Gracias a <span id="easter-egg-trigger" class="author-name" style="cursor: pointer; display: inline-block;">Jaime L√≥pez</span> por haber codificado esta aplicaci√≥n
                    <span id="heart-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></span>
                </p>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/plugin/notes/notes.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/plugin/markdown/markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/plugin/highlight/highlight.min.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ],
            controls: true,
            progress: true,
            center: true,
            navigationMode: 'default',
            transition: 'slide',
            slideNumber: true,
            keyboard: true,
            overview: true
        });

        function verificarVirgilio() {
            const respuesta = document.getElementById('respuestaVirgilio').value.toLowerCase();
            const resultado = document.getElementById('resultadoVirgilio');

            if (respuesta === 'eneas') {
                resultado.textContent = "¬°Correcto! Eneas es el h√©roe que huye de Troya.";
                resultado.style.color = "green";
            } else {
                resultado.textContent = "Incorrecto. Intenta de nuevo.";
                resultado.style.color = "red";
            }
        }

        function evaluarResumenCiceron() {
            const resumen = document.getElementById('resumenCiceron').value;
            const feedback = document.getElementById('feedbackCiceron');

            if (resumen.length > 100) {
                feedback.textContent = "¬°Excelente resumen! Demuestras conocer la importancia de Cicer√≥n.";
                feedback.style.color = "green";
            } else {
                feedback.textContent = "Tu resumen es un poco corto. Intenta a√±adir m√°s detalles sobre la importancia de Cicer√≥n.";
                feedback.style.color = "orange";
            }
        }

        function evaluarReflexion() {
            const reflexion = document.getElementById('reflexionFinal').value;
            const feedback = document.getElementById('feedbackReflexion');

            if (reflexion.length > 150) {
                feedback.textContent = "¬°Una reflexi√≥n muy interesante!  Gracias por compartir tu opini√≥n.";
                feedback.style.color = "green";
            } else {
                feedback.textContent = "Tu reflexi√≥n podr√≠a ser m√°s elaborada. Considera a√±adir m√°s detalles sobre por qu√© el escritor que elegiste es relevante hoy en d√≠a.";
                feedback.style.color = "orange";
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const draggables = document.querySelectorAll('.draggable');
            const dropzones = document.querySelectorAll('.dropzone');

            draggables.forEach(draggable => {
                draggable.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', e.target.innerText);
                    e.target.classList.add('dragging');
                });

                draggable.addEventListener('dragend', e => {
                    e.target.classList.remove('dragging');
                });
            });

            dropzones.forEach(dropzone => {
                dropzone.addEventListener('dragover', e => {
                    e.preventDefault();
                    dropzone.classList.add('active');
                });

                dropzone.addEventListener('dragleave', () => {
                    dropzone.classList.remove('active');
                });

                dropzone.addEventListener('drop', e => {
                    e.preventDefault();
                    const text = e.dataTransfer.getData('text/plain');
                    dropzone.textContent = text;
                    dropzone.classList.remove('active');
                    
                    checkVirgilioAnswers();
                });
            });
        });

        function checkVirgilioAnswers() {
            // Only target dropzones from Reto 1 by excluding those with the ovidio-dropzone class
            const dropzones = document.querySelectorAll('.dropzone:not(.ovidio-dropzone)');
            let allCorrect = true;

            dropzones.forEach(zone => {
                const isCorrect = zone.textContent === zone.dataset.answer;
                zone.style.backgroundColor = isCorrect ? 'rgba(76, 175, 80, 0.2)' : 'rgba(244, 67, 54, 0.2)';
                if (!isCorrect) allCorrect = false;
            });

            const feedback = document.getElementById('virgilio-feedback');
            feedback.textContent = allCorrect ? '¬°Correcto! Has completado el texto perfectamente.' : 'Algunas respuestas no son correctas. ¬°Int√©ntalo de nuevo!';
            feedback.className = `feedback ${allCorrect ? 'success' : 'error'}`;
        }

        function initSortableList() {
            const items = document.querySelectorAll('.sortable-item');
            
            items.forEach(item => {
                item.setAttribute('draggable', true);
                
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', e.target.dataset.order);
                    item.classList.add('dragging');
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const dragging = document.querySelector('.dragging');
                    const items = [...document.querySelectorAll('.sortable-item:not(.dragging)')];
                    const afterElement = items.reduce((closest, child) => {
                        const box = child.getBoundingClientRect();
                        const offset = e.clientY - box.top - box.height / 2;
                        if (offset < 0 && offset > closest.offset) {
                            return { offset: offset, element: child };
                        } else {
                            return closest;
                        }
                    }, { offset: Number.NEGATIVE_INFINITY }).element;

                    if (afterElement) {
                        afterElement.parentElement.insertBefore(dragging, afterElement);
                    } else {
                        item.parentElement.appendChild(dragging);
                    }
                });
            });
        }

        function checkCiceroOrder() {
            // Get the sortable list container
            const sortableList = document.querySelector('.sortable-list');
            if (!sortableList) {
                console.error("Sortable list container not found");
                return;
            }
            
            // Get items in their current DOM order
            const items = Array.from(sortableList.querySelectorAll('.sortable-item'));
            
            if (items.length === 0) {
                console.error("No sortable items found");
                return;
            }
            
            // Get current data-order values in the DOM order
            const currentOrder = items.map(item => parseInt(item.dataset.order));
            console.log("Current order of data-order values:", currentOrder);
            
            // Check if the data-order values are in ascending order (1,2,3,4,5)
            const expectedOrder = [1, 2, 3, 4, 5];
            const isCorrect = currentOrder.every((value, index) => value === expectedOrder[index]);
            
            const feedback = document.getElementById('cicero-feedback');
            if (!feedback) {
                console.error("Feedback element not found");
                return;
            }
            
            feedback.textContent = isCorrect ? '¬°Correcto! Has ordenado los eventos perfectamente.' : 'El orden no es correcto. ¬°Int√©ntalo de nuevo!';
            feedback.className = `feedback ${isCorrect ? 'success' : 'error'}`;
        }

        function initMemoryGame() {
            const pairs = [
                { id: 1, text1: 'Virgilio', text2: 'Eneida' },
                { id: 2, text1: 'Ovidio', text2: 'Metamorfosis' },
                { id: 3, text1: 'Cicer√≥n', text2: 'Catilinarias' },
                { id: 4, text1: 'Horacio', text2: 'Odas' },
                { id: 5, text1: 'S√©neca', text2: 'Medea' },
                { id: 6, text1: 'Plauto', text2: 'Aulularia' }
            ];

            const cardsData = [];
            pairs.forEach(pair => {
                cardsData.push({ id: pair.id, content: pair.text1 });
                cardsData.push({ id: pair.id, content: pair.text2 });
            });

            shuffleArray(cardsData);

            const grid = document.querySelector('.memory-grid');
            grid.innerHTML = cardsData.map((card, index) => `
                <div class="memory-card" data-id="${card.id}" data-unique="${index}">
                    <div class="card-inner">
                        <div class="card-front">?</div>
                        <div class="card-back">${card.content}</div>
                    </div>
                </div>
            `).join('');

            let flippedCards = [];
            let canFlip = true;
            let matchedPairs = 0;

            grid.addEventListener('click', e => {
                const card = e.target.closest('.memory-card');
                if (!card || !canFlip || card.classList.contains('flipped') || card.classList.contains('matched')) return;

                flipCard(card);
                flippedCards.push(card);

                if (flippedCards.length === 2) {
                    canFlip = false;
                    checkMatch();
                }
            });

            function flipCard(card) {
                card.classList.add('flipped');
            }

            function checkMatch() {
                const [card1, card2] = flippedCards;
                const match = card1.dataset.id === card2.dataset.id;

                if (match) {
                    card1.classList.add('matched');
                    card2.classList.add('matched');
                    matchedPairs++;
                    flippedCards = [];
                    canFlip = true;
                    updateScore();
                } else {
                    setTimeout(() => {
                        card1.classList.remove('flipped');
                        card2.classList.remove('flipped');
                        flippedCards = [];
                        canFlip = true;
                    }, 1000);
                }
            }

            function updateScore() {
                document.getElementById('memory-score').textContent = `Parejas encontradas: ${matchedPairs}/6`;
                if (matchedPairs === 6) {
                    setTimeout(() => {
                        alert('¬°Felicidades! Has encontrado todas las parejas.');
                    }, 300);
                }
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function initWordSearch() {
            const gridElement = document.getElementById('wordSearchGrid');
            const wordListElement = document.getElementById('wordList');

            if (!gridElement || !wordListElement) {
                console.error("Word search container elements ('wordSearchGrid' or 'wordList') not found!");
                return;
            }

            const words = ['POETA', 'LIBER', 'VERBA', 'AUCTOR', 'CARMEN'];
            const gridSize = 10;
            let grid = [];
            let foundWords = new Set();
            let selectedCells = [];
            
            for (let i = 0; i < gridSize; i++) {
                grid[i] = new Array(gridSize).fill('');
            }
            
            words.forEach(word => {
                let placed = false;
                let attempts = 0;
                while (!placed && attempts < 100) {
                    const preferredDirection = (attempts % 4 < 2) ? (Math.random() < 0.5 ? 'horizontal' : 'vertical') : (Math.random() < 0.5 ? 'vertical' : 'horizontal');
                    const row = Math.floor(Math.random() * gridSize);
                    const col = Math.floor(Math.random() * gridSize);

                    if (canPlaceWord(word, row, col, preferredDirection)) {
                        placeWord(word, row, col, preferredDirection);
                        placed = true;
                    } else {
                        const otherDirection = preferredDirection === 'horizontal' ? 'vertical' : 'horizontal';
                        if (canPlaceWord(word, row, col, otherDirection)) {
                            placeWord(word, row, col, otherDirection);
                            placed = true;
                        }
                    }
                    attempts++;
                }
                if (!placed) {
                    console.warn(`Could not place word: ${word} after ${attempts} attempts.`);
                }
            });
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (grid[i][j] === '') {
                        grid[i][j] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
                    }
                }
            }
            
            gridElement.innerHTML = '';
            grid.forEach((row, i) => {
                row.forEach((letter, j) => {
                    const cell = document.createElement('div');
                    cell.className = 'word-cell';
                    cell.textContent = letter;
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    gridElement.appendChild(cell);
                });
            });
            
            wordListElement.innerHTML = words.map(word => `<li>${word}</li>`).join('');
            
            let isSelecting = false;
            
            gridElement.addEventListener('mousedown', e => {
                const cell = e.target.closest('.word-cell');
                if (!cell) return;
                isSelecting = true;
                selectedCells = [cell];
                cell.classList.add('selected');
                e.preventDefault();
            });
            
            gridElement.addEventListener('mouseover', e => {
                if (!isSelecting) return;
                const cell = e.target.closest('.word-cell');
                if (cell && !selectedCells.includes(cell)) {
                    const lastCell = selectedCells[selectedCells.length - 1];
                    const lastRow = parseInt(lastCell.dataset.row);
                    const lastCol = parseInt(lastCell.dataset.col);
                    const currentRow = parseInt(cell.dataset.row);
                    const currentCol = parseInt(cell.dataset.col);

                    if (Math.abs(currentRow - lastRow) <= 1 && Math.abs(currentCol - lastCol) <= 1) {
                        if (selectedCells.length > 1) {
                            const firstCell = selectedCells[0];
                            const firstRow = parseInt(firstCell.dataset.row);
                            const firstCol = parseInt(firstCell.dataset.col);
                            const currentDeltaRow = currentRow - firstRow;
                            const currentDeltaCol = currentCol - firstCol;
                            const lastDeltaRow = lastRow - firstRow;
                            const lastDeltaCol = lastCol - firstCol;

                            const isHorizontal = currentDeltaRow === 0 && lastDeltaRow === 0;
                            const isVertical = currentDeltaCol === 0 && lastDeltaCol === 0;
                            const isDiagonal = Math.abs(currentDeltaRow) === Math.abs(currentDeltaCol) && Math.abs(lastDeltaRow) === Math.abs(lastDeltaCol) && Math.sign(currentDeltaRow) === Math.sign(lastDeltaRow) && Math.sign(currentDeltaCol) === Math.sign(lastDeltaCol);

                            if (isHorizontal || isVertical || isDiagonal) {
                                selectedCells.push(cell);
                                cell.classList.add('selected');
                            }
                        } else {
                            selectedCells.push(cell);
                            cell.classList.add('selected');
                        }
                    }
                }
            });
            
            window.addEventListener('mouseup', () => {
                if (!isSelecting) return;
                isSelecting = false;
                
                const word = getSelectedWord();
                const reversedWord = word.split('').reverse().join('');

                if ((words.includes(word) || words.includes(reversedWord)) && !foundWords.has(word) && !foundWords.has(reversedWord) ) {
                     const correctWord = words.includes(word) ? word : reversedWord;
                     foundWords.add(correctWord);
                    selectedCells.forEach(cell => {
                        cell.classList.remove('selected');
                        cell.classList.add('highlighted');
                    });
                    markWordAsFound(correctWord);
                    
                    if (foundWords.size === words.length) {
                        setTimeout(() => {
                           alert('¬°Felicitaciones! Has encontrado todas las palabras.');
                        }, 300);
                    }
                } else {
                    selectedCells.forEach(cell => cell.classList.remove('selected'));
                }
                selectedCells = [];
            });
            
             function canPlaceWord(word, row, col, direction) {
                 if (direction === 'horizontal') {
                     if (col + word.length > gridSize) return false;
                     for (let i = 0; i < word.length; i++) {
                         if (grid[row][col + i] !== '' && grid[row][col + i] !== word[i]) return false;
                     }
                 } else {
                     if (row + word.length > gridSize) return false;
                     for (let i = 0; i < word.length; i++) {
                         if (grid[row + i][col] !== '' && grid[row + i][col] !== word[i]) return false;
                     }
                 }
                 return true;
             }

             function placeWord(word, row, col, direction) {
                 for (let i = 0; i < word.length; i++) {
                     if (direction === 'horizontal') {
                         grid[row][col + i] = word[i];
                     } else {
                         grid[row + i][col] = word[i];
                     }
                 }
             }
            function getSelectedWord() {
                 return selectedCells.map(cell => cell.textContent).join('');
            }
            
            function markWordAsFound(word) {
                const wordItems = wordListElement.getElementsByTagName('li');
                for (const item of wordItems) {
                    if (item.textContent === word) {
                        item.classList.add('found');
                        break;
                    }
                }
            }
        }

        function initLegacyMatch() {
            const writersColumn = document.getElementById('writersColumn');
            const influencesColumn = document.getElementById('influencesColumn');
            const feedbackElement = document.getElementById('legacy-feedback');
            
            if (!writersColumn || !influencesColumn || !feedbackElement) {
                 console.error("Legacy match elements not found!");
                 return;
            }

            let selectedWriter = null;
            let matchedPairs = 0;
            const totalPairs = writersColumn.querySelectorAll('.legacy-item').length;

            writersColumn.addEventListener('click', (e) => {
                const target = e.target.closest('.legacy-item');
                if (!target || target.classList.contains('matched')) return;

                if (selectedWriter === target) {
                    selectedWriter.classList.remove('selected');
                    selectedWriter = null;
                } else {
                    if (selectedWriter) {
                        selectedWriter.classList.remove('selected');
                    }
                    selectedWriter = target;
                    selectedWriter.classList.add('selected');
                    feedbackElement.textContent = `Has seleccionado a ${selectedWriter.textContent}. Ahora haz clic en su influencia.`;
                    feedbackElement.className = 'feedback';
                }
            });

            influencesColumn.addEventListener('click', (e) => {
                const target = e.target.closest('.legacy-item');
                if (!target || target.classList.contains('matched') || !selectedWriter) return;

                const writerId = selectedWriter.dataset.id;
                const influenceMatch = target.dataset.match;

                if (writerId === influenceMatch) {
                    selectedWriter.classList.remove('selected');
                    selectedWriter.classList.add('matched');
                    target.classList.add('matched');
                    
                    matchedPairs++;
                    feedbackElement.textContent = `¬°Correcto! ${selectedWriter.textContent} est√° conectado con ${target.textContent}.`;
                    feedbackElement.className = 'feedback success';
                    selectedWriter = null;

                    if (matchedPairs === totalPairs) {
                         setTimeout(() => {
                            feedbackElement.textContent = '¬°Excelente! Has conectado todo el legado correctamente.';
                         }, 500);
                    }

                } else {
                    feedbackElement.textContent = `Incorrecto. ${selectedWriter.textContent} no est√° directamente relacionado con ${target.textContent}. Intenta de nuevo.`;
                    feedbackElement.className = 'feedback error';
                    selectedWriter.classList.remove('selected');
                    selectedWriter = null;
                }
            });
        }

        function initEasterEgg() {
            const trigger = document.getElementById('easter-egg-trigger');
            const heartContainer = document.getElementById('heart-container');

            if (!trigger || !heartContainer) {
                 console.error("Easter egg elements not found!");
                 return;
            }

            let clickCount = 0;
            let lastClickTime = 0;
            const tripleClickThreshold = 500;

            trigger.addEventListener('click', (event) => {
                const now = Date.now();

                if (now - lastClickTime < tripleClickThreshold) {
                    clickCount++;
                } else {
                    clickCount = 1;
                }
                lastClickTime = now;

                if (clickCount >= 3) {
                    createHeart(trigger, heartContainer);
                }
            });
        }

        function createHeart(triggerElement, container) {
            const heart = document.createElement('div');
            heart.textContent = '‚ù§Ô∏è';
            heart.className = 'flying-heart';

            const rect = triggerElement.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            const baseX = rect.left - containerRect.left + (rect.width / 2);
            const baseY = rect.top - containerRect.top + (rect.height / 2);

            const offsetX = (Math.random() - 0.5) * 60;
            const offsetY = (Math.random() - 0.5) * 40;

            heart.style.left = `${baseX + offsetX}px`;
            heart.style.top = `${baseY + offsetY}px`;

            container.appendChild(heart);

            setTimeout(() => {
                heart.remove();
            }, 1000);
        }

        function initOvidioGame() {
            const draggablesOvidio = document.querySelectorAll('#drag-container-ovidio .draggable');
            const dropzonesOvidio = document.querySelectorAll('.ovidio-dropzone');
            const feedbackOvidio = document.getElementById('ovidio-feedback');

            if (!draggablesOvidio.length || !dropzonesOvidio.length || !feedbackOvidio) {
                // console.warn("Ovidio game elements not found, skipping init.");
                return;
            }

            draggablesOvidio.forEach(draggable => {
                draggable.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', e.target.innerText);
                    e.target.classList.add('dragging');
                });
                draggable.addEventListener('dragend', e => {
                    e.target.classList.remove('dragging');
                });
            });

            dropzonesOvidio.forEach(dropzone => {
                dropzone.addEventListener('dragover', e => {
                    e.preventDefault();
                    dropzone.classList.add('active');
                });
                dropzone.addEventListener('dragleave', () => {
                    dropzone.classList.remove('active');
                });
                dropzone.addEventListener('drop', e => {
                    e.preventDefault();
                    const text = e.dataTransfer.getData('text/plain');
                    dropzone.textContent = text;
                    dropzone.classList.remove('active');
                    checkOvidioAnswers();
                });
            });

            function checkOvidioAnswers() {
                let allCorrect = true;
                dropzonesOvidio.forEach(zone => {
                    const isCorrect = zone.textContent === zone.dataset.answer;
                    zone.style.backgroundColor = isCorrect ? 'rgba(76, 175, 80, 0.2)' : 'rgba(244, 67, 54, 0.2)';
                    if (!isCorrect) allCorrect = false;
                });
                feedbackOvidio.textContent = allCorrect ? '¬°Correcto! Has desentra√±ado la metamorfosis.' : 'Algunas respuestas no son correctas. ¬°Int√©ntalo de nuevo!';
                feedbackOvidio.className = `feedback ${allCorrect ? 'success' : 'error'}`;
            }
        }

        function initSenecaSortableList() {
            const sortableListSeneca = document.getElementById('seneca-sortable-list');
            if (!sortableListSeneca) { /* console.warn("Seneca sortable list not found."); */ return; }

            const items = sortableListSeneca.querySelectorAll('.sortable-item');
            items.forEach(item => {
                item.setAttribute('draggable', true);
                item.addEventListener('dragstart', handleDragStartSeneca); // Use new handlers if logic differs
                item.addEventListener('dragend', handleDragEndSeneca);
                item.addEventListener('dragover', handleDragOverSeneca);
                item.addEventListener('drop', handleDropSeneca);
            });
        }

        let draggedItemSeneca = null; // Separate variable for this game

        function handleDragStartSeneca(e) {
            draggedItemSeneca = e.target;
            setTimeout(() => e.target.classList.add('dragging'), 0);
        }
        function handleDragEndSeneca(e) {
            e.target.classList.remove('dragging');
            draggedItemSeneca = null;
        }
        function handleDragOverSeneca(e) {
            e.preventDefault();
            const afterElement = getDragAfterElementSeneca(e.clientY);
            const sortableListSeneca = document.getElementById('seneca-sortable-list');
            if (afterElement == null) {
                sortableListSeneca.appendChild(draggedItemSeneca);
            } else {
                sortableListSeneca.insertBefore(draggedItemSeneca, afterElement);
            }
        }
        function getDragAfterElementSeneca(y) {
            const sortableListSeneca = document.getElementById('seneca-sortable-list');
            const draggableElements = [...sortableListSeneca.querySelectorAll('.sortable-item:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        function handleDropSeneca(e){ /* No specific drop logic needed if dragover handles it */ }


        function checkSenecaOrder() {
            const items = document.querySelectorAll('#seneca-sortable-list .sortable-item');
            const feedback = document.getElementById('seneca-feedback');
            if (!items.length || !feedback) return;

            let isCorrect = true;
            items.forEach((item, index) => {
                if (parseInt(item.dataset.order) !== index + 1) {
                    isCorrect = false;
                }
            });
            feedback.textContent = isCorrect ? '¬°Correcto! Has ordenado la vida de S√©neca.' : 'El orden no es correcto. ¬°Int√©ntalo de nuevo!';
            feedback.className = `feedback ${isCorrect ? 'success' : 'error'}`;
        }

        function initPanteonMemoryGame() {
            const panteonGrid = document.getElementById('panteon-memory-grid');
            const panteonScore = document.getElementById('panteon-memory-score');

            if (!panteonGrid || !panteonScore) {
                // console.warn("Panteon memory game elements not found.");
                return;
            }

            const pairs = [
                { id: 1, text1: 'J√∫piter', text2: 'Zeus' },
                { id: 2, text1: 'Juno', text2: 'Hera' },
                { id: 3, text1: 'Marte', text2: 'Ares' },
                { id: 4, text1: 'Venus', text2: 'Afrodita' },
                { id: 5, text1: 'Neptuno', text2: 'Poseid√≥n' },
                { id: 6, text1: 'Minerva', text2: 'Atenea' }
            ];

            const cardsData = [];
            pairs.forEach(pair => {
                cardsData.push({ id: pair.id, content: pair.text1 });
                cardsData.push({ id: pair.id, content: pair.text2 });
            });

            shuffleArray(cardsData);

            panteonGrid.innerHTML = cardsData.map((card, index) => `
                <div class="memory-card" data-id="${card.id}" data-unique="${index}">
                    <div class="card-inner">
                        <div class="card-front">?</div>
                        <div class="card-back">${card.content}</div>
                    </div>
                </div>
            `).join('');

            let flippedCardsPanteon = [];
            let matchedPairsPanteon = 0;
            let canFlipPanteon = true;

            panteonGrid.addEventListener('click', e => {
                const card = e.target.closest('.memory-card');
                if (!card || !canFlipPanteon || card.classList.contains('flipped') || card.classList.contains('matched')) return;

                card.classList.add('flipped');
                flippedCardsPanteon.push(card);

                if (flippedCardsPanteon.length === 2) {
                    canFlipPanteon = false;
                    checkPanteonMatch();
                }
            });

            function checkPanteonMatch() {
                const [card1, card2] = flippedCardsPanteon;
                const match = card1.dataset.id === card2.dataset.id;

                if (match) {
                    card1.classList.add('matched');
                    card2.classList.add('matched');
                    matchedPairsPanteon++;
                    updatePanteonScore();
                    flippedCardsPanteon = [];
                    canFlipPanteon = true;
                    if (matchedPairsPanteon === pairs.length) {
                         setTimeout(() => panteonScore.textContent = "¬°Pante√≥n completo!", 300);
                    }
                } else {
                    setTimeout(() => {
                        card1.classList.remove('flipped');
                        card2.classList.remove('flipped');
                        flippedCardsPanteon = [];
                        canFlipPanteon = true;
                    }, 1000);
                }
            }
            function updatePanteonScore() {
                panteonScore.textContent = `Parejas encontradas: ${matchedPairsPanteon}/${pairs.length}`;
            }
        }

        function initWordSearchVida() {
            const gridElement = document.getElementById('wordSearchGridVida');
            const wordListElement = document.getElementById('wordListVida');

            if (!gridElement || !wordListElement) {
                return;
            }

            // Clear previous grid if any
            gridElement.innerHTML = '';
            
            // Ensure proper grid layout
            gridElement.style.display = 'grid';
            gridElement.style.gridTemplateColumns = 'repeat(10, 40px)';
            gridElement.style.gridTemplateRows = 'repeat(10, 40px)';
            gridElement.style.gap = '1px';

            const wordsVida = ['DOMUS', 'FORUM', 'SENATUS', 'AQUA', 'VIA', 'CIVIS'];
            const gridSizeVida = 10;
            let gridVida = [];
            let foundWordsVida = new Set();
            let selectedCellsVida = [];

            // Initialize empty grid
            for (let i = 0; i < gridSizeVida; i++) {
                gridVida[i] = new Array(gridSizeVida).fill('');
            }

            // Place words with both horizontal and vertical directions
            wordsVida.forEach((word, index) => {
                let placed = false;
                let attempts = 0;
                // Alternate between horizontal and vertical for better distribution
                const initialDirection = index % 2 === 0 ? 'horizontal' : 'vertical';
                
                while (!placed && attempts < 100) {
                    // Try different directions and positions
                    const direction = attempts % 2 === 0 ? initialDirection : (initialDirection === 'horizontal' ? 'vertical' : 'horizontal');
                    const row = Math.floor(Math.random() * gridSizeVida);
                    const col = Math.floor(Math.random() * gridSizeVida);
                    
                    if (canPlaceWordGeneric(gridVida, word, row, col, direction, gridSizeVida)) {
                        placeWordGeneric(gridVida, word, row, col, direction);
                        placed = true;
                    }
                    attempts++;
                }
            });

            // Fill remaining
            for (let i = 0; i < gridSizeVida; i++) {
                for (let j = 0; j < gridSizeVida; j++) {
                    if (gridVida[i][j] === '') {
                        gridVida[i][j] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
                    }
                }
            }

            // Create HTML
            gridVida.forEach((row, i) => {
                row.forEach((letter, j) => {
                    const cell = document.createElement('div');
                    cell.className = 'word-cell';
                    cell.textContent = letter;
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    gridElement.appendChild(cell);
                });
            });

            // Add words to the word list with same styling as in Reto 4
            wordListElement.innerHTML = '';
            wordsVida.forEach(word => {
                const li = document.createElement('li');
                li.textContent = word;
                wordListElement.appendChild(li);
            });

            // Selection Logic
            let isSelectingVida = false;
            
            gridElement.addEventListener('mousedown', e => {
                const cell = e.target.closest('.word-cell');
                if (!cell) return;
                isSelectingVida = true;
                selectedCellsVida = [cell];
                cell.classList.add('selected');
                e.preventDefault();
            });
            
            gridElement.addEventListener('mouseover', e => {
                if (!isSelectingVida) return;
                const cell = e.target.closest('.word-cell');
                if (cell && !selectedCellsVida.includes(cell)) {
                    const lastCell = selectedCellsVida[selectedCellsVida.length - 1];
                    const lastRow = parseInt(lastCell.dataset.row);
                    const lastCol = parseInt(lastCell.dataset.col);
                    const currentRow = parseInt(cell.dataset.row);
                    const currentCol = parseInt(cell.dataset.col);

                    // Check if we're selecting in a straight line
                    const rowDiff = currentRow - lastRow;
                    const colDiff = currentCol - lastCol;
                    
                    // Only allow selection of adjacent cells in straight lines
                    if ((rowDiff === 0 && Math.abs(colDiff) === 1) || // Horizontal
                        (colDiff === 0 && Math.abs(rowDiff) === 1) || // Vertical
                        (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 1)) { // Diagonal
                        
                        if (selectedCellsVida.length === 1) {
                            selectedCellsVida.push(cell);
                            cell.classList.add('selected');
                        } else {
                            // Ensure we're continuing in the same direction
                            const firstCell = selectedCellsVida[0];
                            const direction = getSelectionDirection(parseInt(firstCell.dataset.row), 
                                                                 parseInt(firstCell.dataset.col),
                                                                 lastRow, lastCol);
                            
                            if (direction === getSelectionDirection(lastRow, lastCol, currentRow, currentCol)) {
                                selectedCellsVida.push(cell);
                                cell.classList.add('selected');
                            }
                        }
                    }
                }
            });
            
            window.addEventListener('mouseup', function() {
                if (!isSelectingVida) return;
                isSelectingVida = false;
                
                const word = selectedCellsVida.map(cell => cell.textContent).join('');
                const reversedWord = word.split('').reverse().join('');

                if ((wordsVida.includes(word) || wordsVida.includes(reversedWord)) && 
                    !foundWordsVida.has(word) && !foundWordsVida.has(reversedWord)) {
                    
                    const correctWord = wordsVida.includes(word) ? word : reversedWord;
                    foundWordsVida.add(correctWord);
                    
                    selectedCellsVida.forEach(cell => {
                        cell.classList.remove('selected');
                        cell.classList.add('highlighted');
                    });
                    
                    markWordAsFoundGeneric(wordListElement, correctWord);
                    
                    if (foundWordsVida.size === wordsVida.length) {
                        setTimeout(() => alert('¬°Felicidades! Has encontrado todas las palabras.'), 300);
                    }
                } else {
                    selectedCellsVida.forEach(cell => cell.classList.remove('selected'));
                }
                
                selectedCellsVida = [];
            });
        }

        // Generic helpers for word search duplicates
        function canPlaceWordGeneric(grid, word, row, col, direction, gridSize) {
            if (direction === 'horizontal') {
                if (col + word.length > gridSize) return false;
                for (let i = 0; i < word.length; i++) {
                    if (grid[row][col + i] !== '' && grid[row][col + i] !== word[i]) return false;
                }
            } else { // Vertical
                if (row + word.length > gridSize) return false;
                for (let i = 0; i < word.length; i++) {
                    if (grid[row + i][col] !== '' && grid[row + i][col] !== word[i]) return false;
                }
            }
            return true;
        }
        function placeWordGeneric(grid, word, row, col, direction) {
            for (let i = 0; i < word.length; i++) {
                if (direction === 'horizontal') {
                    grid[row][col + i] = word[i];
                } else { grid[row + i][col] = word[i]; }
            }
        }
        function markWordAsFoundGeneric(listElement, word) {
            const items = listElement.getElementsByTagName('li');
            for (const item of items) {
                if (item.textContent === word) {
                    item.classList.add('found');
                    break;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initSortableList();
            initMemoryGame();
            initWordSearch();
            initLegacyMatch();
            initEasterEgg();
            initOvidioGame();
            initSenecaSortableList();
            initPanteonMemoryGame();
            initWordSearchVida();
        });

        // Reto 2: Cicer√≥n sortable list
        function initSortableCiceron() {
            const list = document.getElementById('cicero-list');
            if (!list) return;
            
            const items = Array.from(list.children);
            shuffleArray(items);
            
            items.forEach(item => {
                list.appendChild(item);
                
                item.draggable = true;
                
                item.addEventListener('dragstart', () => {
                    item.classList.add('dragging');
                });
                
                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                });
            });
            
            list.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(list, e.clientY);
                const draggable = document.querySelector('.dragging');
                if (afterElement == null) {
                    list.appendChild(draggable);
                } else {
                    list.insertBefore(draggable, afterElement);
                }
            });
        }
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.sortable-item:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        
        function checkCiceroOrder() {
            // Get the sortable list container
            const sortableList = document.querySelector('.sortable-list');
            if (!sortableList) {
                console.error("Sortable list container not found");
                return;
            }
            
            // Get items in their current DOM order
            const items = Array.from(sortableList.querySelectorAll('.sortable-item'));
            
            if (items.length === 0) {
                console.error("No sortable items found");
                return;
            }
            
            // Get current data-order values in the DOM order
            const currentOrder = items.map(item => parseInt(item.dataset.order));
            console.log("Current order of data-order values:", currentOrder);
            
            // Check if the data-order values are in ascending order (1,2,3,4,5)
            const expectedOrder = [1, 2, 3, 4, 5];
            const isCorrect = currentOrder.every((value, index) => value === expectedOrder[index]);
            
            const feedback = document.getElementById('cicero-feedback');
            if (!feedback) {
                console.error("Feedback element not found");
                return;
            }
            
            feedback.textContent = isCorrect ? '¬°Correcto! Has ordenado los eventos perfectamente.' : 'El orden no es correcto. ¬°Int√©ntalo de nuevo!';
            feedback.className = `feedback ${isCorrect ? 'success' : 'error'}`;
        }
        
        // ... existing code ...
        
        // Common wordSearch functions
        function getSelectionDirection(row1, col1, row2, col2) {
            if (row1 === row2) return 'horizontal';
            if (col1 === col2) return 'vertical';
            if (Math.abs(row1 - row2) === Math.abs(col1 - col2)) return 'diagonal';
            return 'unknown';
        }
        
        // ... existing code ...
    </script>


</body>
</html>